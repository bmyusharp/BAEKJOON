# 2061. 좋은 암호

[문제 보기](https://www.acmicpc.net/problem/2061)

- 풀이

주어진 K를 소인수분해하여, 1을 제외한 모든 인수가 L보다 큰지 확인해야 하는 문제이다.

문제에서는 매우 큰 두 소수라고 언급했으나, 여러 개의 소수가 있을 수도 있다는 점을 가정하고, 모든 소인수를 구할 것이다. K가 4 이상이므로 (K / 2 - 0.5)의 수까지 K를 나눠볼 것이다(그 이상은 의미가 없음)

```python
input_kl = list(input().split())
k = int(input_kl[0])
l = int(input_kl[1])
#입력부분

#K가 짝수인 경우 (그리고 L이 2인 경우) (edge case)
if k % 2 == 0: 
    if l == 2:
        print('GOOD')
    else: #L이 2가 아닌데 K에 2 인수가 있는 경우
        print(f'BAD 2')

#그 외의 경우는 모두 소인수 분해를 합니다.
#K는 홀수입니다.
sosu = []
for i in range(3, int(k / 2)): #3부터 K의 절반인 수 까지, 예를 들어 K가 13이라면 6까지
    if k % i == 0: #i가 K의 인수라면...
        sosu.append(i)
#3부터 셌으니까 sosu에는 K의 1과 K를 제외한 인수가 들어가 있을 것이다.
#L과 비교해서 미만인 게 하나라도 있다면 BAD를 출력
tf = []
for j in sosu:
    if j < l:
        print(f'BAD {j}')
        tf.append(False)
if False not in tf:
    print('GOOD')
#미만인 게 하나도 없다면 GOOD을 출력
```

제출 결과...

![image-20220202093347830](C:\Users\1004r\AppData\Roaming\Typora\typora-user-images\image-20220202093347830.png)

단순한 반복문 구문으로는 K의 범위인 10의 100승까지 계산하는 것이 시간이 지나치게 오래 걸리는 것 같습니다. 홀수만 계산하도록 range 3번째 파라미터에 2를 넣어도 마찬가지였습니다.

그래서, 알고리즘을 손봤습니다.

먼저, 제곱근 범위 나누기법입니다.

소수 여부를 검사하는 과정에서 저는 K/2까지 검사하였습니다. 짝수가 아닌, 즉 2를 인수로 갖지 않는 K에 대하여 K의 절반 이하로만 검사하면 된다는 이론이었습니다.

제곱근 범위 나누기법은 거기에서 한 단계 더 나아간 방법입니다. 인수의 곱으로 이루어짐을 판단하는 것이기 때문에, 인수의 범위는 반드시 K의 제곱근보다 작을 것이기 때문입니다. 이는 4 이상인 K에 대해서 K/2보다 더 적은 수를 검사하는 것이므로 훨씬 빠릅니다.

문제의 예제인 143의 경우 제곱근이 11.958... 로 11까지의 수만 나누면 검사할 수 있습니다.

이를 적용해서 반복문 부분을 고쳤습니다. 제곱근은 `math`를 사용하여 구했습니다.

```python
import math
...
for i in range(3, int(math.sqrt(k)), 2): #3부터 K의 제곱근까지 홀수마다 검사
...
```

제출 결과...

![image-20220202101730348](C:\Users\1004r\AppData\Roaming\Typora\typora-user-images\image-20220202101730348.png)

여전히 시간 초과가 나옵니다. 무슨 이유일까요?

시간 제한은 2초인데 10의 50제곱까지 반복할 수 없기 때문입니다. PyPy3로 제출해도 마찬가지였습니다. 알고리즘의 수정이 필요한 부분입니다.